	In implementarea evaluatorului pentru TDA am folosit o functie auxiliara evalTest ce lua ca parametru un program si evalua programul respectiv apeland functia evaluateProg; aceasta returna fie un String, atunci cand undeva in evaluarea programului s-a intalnit o variabila neinitializata fie rezultatul final al evaluarii in caz de succes. Cele 2 functii de evaluare evaluateProg si evaluateExpr returneaza un triplet de forma (val_de_return, valoare, stare_curenta_a_map-ului) intru-cat map-ul folosit pentru a retine variabilele definite impreuna cu valorile lor se putea modifica constant si singura metoda de a-l face vizibil in orice functie era sa fie dat ca parametru. In evalTest insa, in ultima instanta, atunci cand s-a facut evaluarea programului, pentru Right se va mai testa si ret_val care ne spune daca de-a lungul programului s-a intalnit return sau nu. Daca nu s-a intalnit atunci se va returna al doilea mesaj de eroare iar daca da(ret_val fiind 1 in acest caz) se va returna valoarea propriu-zisa la care s-a evaluat (de map nu mai este nevoie).
	Cele 2 functii de baza sunt evaluateProg si evaluateExpr. Acestea sunt implementate pentru fiecare constructor al tipurilor Prog si Expr. Deci, pentru Expr avem functia evaluateExpr care primeste ca parametrii un map care retine contextul curent(variabilele declarate pana in acel moment cu valorile corespunzatoare) si o expresie ce trebuie evaluata. Avem cate o implementare pentru fiecare constructor astfel: pentru Value am ales sa introduc o variabila "x" cu valoarea data ca parametru intr-un map nou iar apoi sa testez daca exista in acel map(valoarea existand mereu) in acest fel returnand ceva de tipul Maybe a pe care sa il corelez cu Either, functia returnand mereu un triplet format din variabila care spune daca suntem intr-un Return sau nu, valoarea transmisa ca parametru ca Int si un map formal, care in acest context nu are relevanta(insa se foloseste pentru a respecta signatura). Pentru Symbol caut folosind functia lookup variabila data ca parametru in map-ul dat si el ca parametru. Din nou lookup returneaza ceva de tip Maybe a, si corelez Nothing si Just cu Left si Right pentru ca in final sa fie ceva de tip Either. Ca si anterior, daca variabila exista deja se returneaza ret_val, valoarea ei si map-ul curent, daca nu se trimite mesaj corespunzator. Pentru Smaller, care primeste 2 expresii mai intai evaluam prima expresie, folosind aceeasi functie evaluateExpr; daca in evaluarea ei s-au intalnit variabile neinitializate acest lucru se transmite si ajunge sa face matching cu constructorul Left. Daca nu au existat probleme se trece la evaluarea celei de-a doua expresie care se face in mod similar; daca si aceasta a avut loc cu succes atunci vom compara cele 2 valori obtinute la evaluare. Daca prima este mai mica decat a doua, ca si conventie, returnam ret_val, valoarea 1 si map-ul curent, in caz contrar returnand ret_val, -1 si map-ul. Pentru Equal se face in mod similar, testandu-se insa daca cele 2 valori sunt egale si returnand tot ret_val, valoarea 1 si map-ul daca era respectata conditia, respectiv ret_val, -1 si map-ul in caz contrar. Pentru cele 3 operatii Mult, Sub si Add, corespunzand inmultirii, scaderii si adunarii se face la fel astfel: se evalueaza cele 2 expresii(mai intai prima si se trece la a doua doar daca nu a existat vreo eroare care s-a propagat pana la acest pas) si daca nu au existat erori se returneaza valoarea obtinuta in urma aplicarii operatiei specifice pe cele 2 valori ale expresiilor.
	Pentru tipul Prog am folosit functia evaluateProg ce ia ca parametru tot un map cu starea curenta si un program ce trebuie parcurs si care aduce modificari contextului dat de map. Avem urmatorii constructori: pentru Eq primim o variabila ce trebuie introdusa in map si o expresie. Incercam sa evaluam expresia si daca s-a evaluat cu succes(deci avem o valoare pentru ea) vom returna tripletul format din ret_val(care este tot 0 - asa s-a transmis- deoarece inca nu am dat de un Return), valoarea expresiei(care nu are vreo relevanta insa trebuie facut acest lucru pentru a pastra signatura) si map-ul obtinut in urma actualizarii cu variabila data. Pentru If evaluam mai intai expresia care spune pe ce ramura se intra: daca nu au existat erori in evaluarea ei testam sa vedem ce s-a obtinut(1 sau -1 deoarece aceasta a fost conventia facuta). Daca avem 1 atunci evaluam primul program altfel il evaluam pe al doilea, in acelasi mod pentru a returna ceva de tip Either. Pentru Seq se evalueaza mai intai primul program: daca s-a inyalnit erori s-au propagat, in caz contrar, verificam valoarea lui ret_val, mia exact daca acest program a continut Return, caz in care evident ne oprim si returnam tripletul format din ret_val, valoarea data de Return si map. Daca nu s-a intalnit Return atunci continuam cu evaluarea programului pentru care la fel putem obtine o eroare sau un rezultat care este returnat. Pentru While se face mai intai o evaluare a expresiei date ca parametru. Daca aceasta a reusit sa se evalueze la o valoare testam daca este 1(daca este adevarata conditia). Daca da evaluam o data programul si daca a avut loc cu succes verificam daca s-a intalnit Return in acest program: daca da, vom return direct valorile obtinute, altfel vom reapela functia evaluateProg cu noul context si exact acelasi program initial While. Daca s-a obtinut insa 0 in urma evaluarii expresiei returnam ret_val, valoarea 0(ca si conventie) si map-ul trimis ca paramatru. Pentru Return evaluam doar expresia data ca parametru pe baza contextului creat de-a lungul intregului program si daca se evalueaza cu succes vom returna ret_val + 1(deci ret_val isi va schimba valoarea in 1 pentru a marca faptul ca exista Return), valoarea la care s-a evaluat expresia si map-ul curent(chiar daca doar valoarea ne intereseaza). Se ajunge astfel in functia evalTest care preia un program intreg si-l evalueaza: daca pe parcursul evaluarii au existat erori(legate de variabile neinitializate) acestea s-au propagat pana aici unde se face afisarea finala. Daca nu, pentru tripletul care a ajuns verificam mai intai valoarea lui ret_val : daca este 0, inseamna ca programul nostru nu este corect deoarece nu exista Return, caz in care returnam folosind Left mesajul corespunzator de "Missing return". Daca este insa 1, inseamna ca a existat Return, deci vom returna a doua valoare din triplet care este exact valoarea la care s-a evaluat expresia din Return (map-ul nu mai conteaza deja).
